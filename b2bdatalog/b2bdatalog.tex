\documentclass[sigconf,screen,review,natbib]{acmart}
\AtBeginDocument{%
\providecommand\BibTeX{{%
\normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}

\acmConference[PPDP '23]{25th International Symposium on
	Principles and Practice of Declarative Programming}{October 22--23,
	2023}{Cascais, Lisbon, Portugal}

\usepackage{microtype}
\usepackage{tikz,tikz-qtree}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows.meta, shapes.misc, positioning}
\usepackage{subfig}
\theoremstyle{definition}
\newtheorem{exmp}{Example}[section]
\usepackage[ruled, vlined, linesnumbered]{algorithm2e}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKwData{typeInt}{Int}
\SetKwData{typeRat}{Rat}
\SetKwData{Defined}{Defined}
\SetKwFunction{parseStatement}{parseStatement}
\usepackage{libertine}

\title{A Differential Datalog Interpreter}

\author{Bruno Rucy Carneiro Alves de Lima}
\orcid{1234-5678-9012}
\affiliation{%
	\institution{University of Tartu}
	\department{Institute of Computer Science}
	\city{Tartu}
	\country{Estonia}
}
\email{bruno98@ut.ee}

\author{Merlin Kramer}
\affiliation{%
	\institution{unaffiliated}
	\city{Wuppertal}
	\country{Germany}
}
\email{merlin.kramer@gmail.com}

\author{Kalmer Apinis}
\affiliation{%
	\institution{University of Tartu}
	\department{Institute of Computer Science}
	\city{Tartu}
	\country{Estonia}
}
\email{kalmera@ut.ee}


% Kalmer: The abstract is too long and too complicated.
% But lets not worry about it too much for now.
\begin{abstract}
	The core reasoning task for datalog engines is materialization, the evaluation of a datalog program over
	a database alongside its physical incorporation into the database itself. The de-facto method of computing
	it, is through the recursive application of inference rules. Due to it being a costly operation, it is a must
	for datalog engines to provide incremental materialization, that is, to adjust the computation to new
	data, instead of restarting from scratch. One of the major caveats, is that deleting data is notoriously more
	involved than adding, since one has to take into account all possible data that has been entailed from what
	is being deleted. Differential Dataflow is a computational model that provides efficient incremental
	maintenance, notoriously with equal performance between additions and deletions, and work distribution, of
	iterative dataflows. In this paper we investigate the performance of materialization with three reference
	datalog implementations, out of which one is built on top of a lightweight relational engine, and the two others
	are differential-dataflow and non-differential versions of the same rewrite algorithm, with the same optimizations.
\end{abstract}

\keywords{datalog, incremental view maintenance, differential dataflow}

\begin{document}

\maketitle

\section{Introduction}
Datalog\cite{datalog}, the canonical language for reasoning over relational databases, ground fact stores, is a
declarative language used to evaluate sets of possibly-recursive restricted horn clauses, programs, while
remaining not Turing complete. Evaluating a program entails computing implicit consequences over a fact
store, yielding new facts.

Materialization, or the physical storage of a program's consequences, eliminates the need for reasoning
during query answering. Maintaining this computation is essential for modern Datalog use-cases, as it
relates to the broader problem of incremental view maintenance.

While the semi-naive evaluation method\cite{datalog} efficiently handles additions, deletions are often less efficient, as
retracting a fact may naively imply deleting all data derived from it. The delete-rederive\cite{dred} method addresses
this issue by computing the materialization adjustment through the generation of new Datalog programs, first
calculating all possible deletions, and then determining alternative derivations. The difference between these
sets represents the actual facts to be deleted.

However, using two distinct algorithms for additions and deletions results in different performance characteristics,
potentially causing severe biases. For example, when a large portion of ground facts are deleted, delete-rederive
could be significantly more expensive than re-materializing.

A promising way to tackle incremental maintenance in a more uniform manner is to use differential dataflow, a
programming model that efficiently processes and maintains large-scale possibly recursive dataflow computations. Central
to it is the notion of fine-grained tracking, with partially-ordered timestamps, and processing differences between
collections of data, rather than entire collections themselves. This approach facilitates efficient updates in response
to changes in the underlying data\cite{differential_dataflow}.

In the context of datalog, differential dataflow presents an opportunity to address the performance challenges
arising from handling additions and deletions. Contrary to traditional methods, such as semi-naive evaluation for
additions and delete-rederive for deletions, differential dataflow provides a unified and efficient approach to
incremental view maintenance.

The utilization of partially ordered timestamps and arrangements allows differential dataflow to precisely
identify affected parts of the computation and to recompute only the necessary components. This leads to
a more efficient handling of incremental updates in Datalog evaluation, as the system can focus on affected
sub-computations rather than re-evaluating the entire program. Furthermore, there also is first-class support
for both automatic parallelism and distributed computing, contributing to enhanced performance and scalability.

DDLog\cite{ddlog} has been the only attempt at building a datalog engine that utilized differential dataflow.
Similarly to the high-profile reasoner Souffle\cite{souffle}, it is a compiler, in which a datalog program
becomes an executable low-level language program, C++ in Souffle's case, and Rust for DDLog. The rationale for
the language choice, is that differential dataflow's canonical implementation lives as a heavily optimized
map-reduce-like framework written in Rust.

Notably, given that DDLog is a compiler, it is not suited for situations where either the program is expected
to be dynamic, with rules being added or removed, or where new programs ought to be evaluated during run
time, therefore restricting its use case to the specific scenarios where such drawbacks are acceptable.

There has been no study evaluating the isolated benefit of differential dataflow to datalog evaluation. Therefore
the suitability of differential dataflow in this context remains unclear, emphasizing the importance of further
research on its potential benefits and limitations in incremental view maintenance.
\paragraph{Contributions.} In this work, we directly address the posited research question by developing a datalog
interpreter utilizing differential dataflow. We then compare our implementation with other prototypical datalog
interpreters, created from scratch, that share as many components as it is reasonable, in order to isolate
the effect of differential dataflow in both runtime performance and memory efficiency. This allows us to more
accurately empirically assess how does differential dataflow in itself fare against more traditional approaches.

Unlike DDLog, which compiles a datalog program into its evaluation as a fixed differential dataflow program, our
approach involves writing a single differential dataflow program capable of evaluating any datalog program. This
eliminates the need for compilation and provides the additional benefit of incremental maintenance for both rule
removals and additions.
\paragraph{Structure of the paper.}
\begin{itemize}
	\item{\textbf{Background.}} A brief recapitulation of the general background, with datalog, its evaluation
	methods, and the delete-rederive method being formally introduced.
	\item{\textbf{Differential Dataflow.}} Differential Dataflow, and the translation of datalog evaluation to
	a dataflow is showcased and explained.
	\item{\textbf{System.}} The developed interpreters are described, alongside with all optimizations and
	benchmark-relevant information.
	\item{\textbf{Benchmarks.}} An empirical evaluation of all reasoners, over multiple different programs and
	datasets is undertaken.
\end{itemize}
\section{Related Work}

\textbf{Differential Dataflow Applications.} There are two relevant differential dataflow projects that are worth
mentioning. One of them is Graspan, a parallel graph processing system that uses differential dataflow for efficient
incremental computation of static program analyses over large codebases.

Graspan models the program analysis problem as a reachability problem on a graph, where nodes represent program elements
and edges represent the relationships between these elements. It leverages differential dataflow to incrementally update
the analysis results in response to changes in the input graph, which can be due to code modifications or updates to
the analysis rules. Graspan has demonstrated its ability to scale to large codebases and provide low-latency updates
for various static analyses, including points-to analysis, control-flow analysis, and data-flow analysis.

Another project of interest is DBSP\cite{dbsp}, a recent development, that started from the need for a more concise
theoretical definition of differential dataflow. All of DBSP operators are based on differential dataflow's, however, its
computational model is less powerful as it does not allow updates to past values in a stream, and it is also assumed that
inputs arrive in time order. DBSP can express both incremental and non-incremental computations, with the former not being
possible in differential dataflow.

\textbf{Datalog engines.} There are two kinds of datalog engines. The first encompasses those that compile
a datalog program to usually a systems-level programming language, and the second are interpreters, able to
evaluate any datalog program.

Soufflé is a prominent example of a datalog compiler that translates datalog programs into high-performance
C++ code. It incorporates several optimization techniques, such as parallel execution with highly specialized data
structures\cite{souffle_btree}, and nearly optimal join ordering\cite{souffle_join}. Notably, its development has
been an unparalleled source of articles on the engineering of reasoners.

DDLog As previously mentioned, compiles datalog to differential dataflow, achieving efficient differential data updates
for datalog programs. It demonstrates the applicability of differential dataflow in the context of declarative logic
programming and incremental view maintenance.

The majority of reasoners recently developed have been mostly interpreters, further split into distributed or
shared memory systems. Out of the shared memory ones, the most notable are RDFox\cite{rdfox}, a highly specialized
and performant reasoner that is tailored to the semantic web needs, RecStep\cite{recstep}, that builds on top of a
highly efficient relational engine, and DCDatalog\cite{dcdatalog}, that builds upon the query optimizer DeALS\cite{deals}
and extends a work that establishes how some linear datalog programs could be evaluated in a lock-free manner, to
general positive programs.

One of the most high-profile datalog papers of interest has been BigDatalog\cite{bigdatalog}, that
originally used the query optimizer DeALs, and was built on top of the very popular Spark\cite{spark}
distribution framework. Soon after, a prototypical implementation\cite{cog} over Flink\cite{flink},
a distribution framework that supports streaming, Cog, followed. Flink, unlike Spark, supports
iteration, so implementing reasoning did not need to extend the core of the underlying framework. The most
successful attempt at creating a distributed implemention has been Nexus\cite{nexus}, that is also built on Flink,
and makes use of its most advanced feature, incremental stream processing.
\section{Background}

\textit{Datalog}\cite{datalog} is a declarative programming language. A program $P$ is a set of
rules $r$, with each $r$ being a restriction of tuple-generating dependencies: \[\bigwedge_{i=1}^kB_i(x_1, ..., x_j) \rightarrow H(x_1, ..., x_j)\]
with $k$, $j$ as finite integers, $x$ as terms, and each $B_i$ and $H$ as predicates. A term can belong
either to the set of variables, or constants. The set of all $B_i$ is called the \textit{body}, and $H$ the \textit{head}.

A rule $r$ is said to be datalog, if no predicate is negated, and all variables in the head appear somewhere in the body,
thereby not there being the possibility for existential variables to exist, conversely, a datalog program is one in which
all rules are datalog.

\begin{exmp}{Datalog Program}\label{ex1}
	\[
		P = \left\{  \begin{array}{l}
			\text{SubClassOf}(?x, ?y) \wedge \text{SubClassOf}(?y, ?z) \rightarrow \text{SubClassOf}(?x, ?z) \\
		\end{array}\right\}
	\]
\end{exmp}
Example \ref{ex1} shows a simple valid recursive program. The only rule denotes that \textit{for all x, y, z, if x is
	in a SubClassOf relation with y, and y is in a SubClassOf relation with z, then it follows that x is in a subClassOf
	relation with z}.

Programs denote implications over a store of ground facts. This store is called the extensional database, $EDB$, and the result
of evaluating a program over some $EDB$ is the $IDB$, the intensional database.

Let $DB = EDB \cup IDB$, and for there to be a program $P$. We define the \textit{immediate consequence} of $P$ over $DB$ as
all facts that are either in $DB$, or stem from the result of applying the rules in $P$ to $DB$. The \textit{immediate consequence operator}
$\textbf{I}_C(DB)$ is the union of $DB$ and its immediate consequence, and the $IDB$, at the moment of the
application of $\textbf{I}_C(DB)$ is the difference of the union of all previous $DB$ with the $EDB$.

It is trivial to see that $I_C(DB)$ is monotone, and given that both the $EDB$ and $P$ are finite sets, and
that $IDB = \emptyset$ at the start, at some point $I_C(DB) = DB$, since there won't be new facts to be inferred. This
point is the \textit{least fixed point} of $I_c(DB)$\cite{datalog}. Computing the \textit{least fixed point} as
described, recursively applying the immediate consequence, is called Naive evaluation.

\subsection{Semi-Naive Evaluation}

The semi-naive evaluation algorithm \cite{datalog} is a widely-used technique for improving naive evaluation.
Given a Datalog program $P$ and an $EDB$, the algorithm iteratively computes the $IDB$ in the same manner as
naive evaluation, with the addition of maintaining a set of new delta facts $\Delta^+$ that are generated in
each iteration, that are utilized in a new delta program $\Delta^+P$.

Given a program $P$ with rules $r_0, ..., r_n$, with bodies $b(r) = \{b_0, ..., b_k\}$ and heads $h(r)$, the
delta program will generate one new $\Delta$rule for each $b_j$ in each rule body $b(r_i)$, in order to
represent that only facts that have been recently inferred are being taken into account.

\begin{exmp}{Semi-naive Evaluation Delta Program}
	\tiny
	\begin{align}
		P = \{ TC(?x, ?z) \leftarrow TC(?x, ?y), TC(?y, ?z); TC(?x, ?y) \leftarrow Edge(?x, ?y) \} \nonumber                                                           \\
		r_0 = TC(?x, ?y) \leftarrow Edge(?x, ?y)                                                                                                                       \\
		\Delta r_1 = TC(?x, ?z) \leftarrow \Delta TC(?x, ?y), TC(?y, ?z)                                                                                     \nonumber \\
		\Delta r_2 = TC(?x, ?z) \leftarrow TC(?x, ?y), \Delta TC(?y, ?z)
	\end{align}
	\label{exsne}
\end{exmp}

In theory, the semi-naive evaluation algorithm improves the efficiency of Datalog evaluation by avoiding
the recomputation of facts that have already been derived in previous iterations. This method is particularly
efficient for certain classes of Datalog programs that are common in practice. Example \ref{exsne} shows
the generated $\Delta$ program. It is worth noting, that there are substantial implementation challenges in order
to ensure that its overhead is not larger than the performance gains, since it possibly requires multiple
indexes and set operations to keep track of the most recently inferred facts.

\subsection{Delete-Rederive}

Both the regular semi-naive and naive evaluation methods are already incremental, and easily handles the
addition of data. One merely has to continue the evaluation with all previous data as the most recent delta.

The most used method for handling deletions is a bottom-up algorithm\cite{dred} that uses semi-naive evaluation
to evaluate two new programs, one that computes all possible deletions that could stem from the deletion of the
facts being retracted, and then another that attempts to find alternative derivations to the overdeleted ones.

Given a program $P$ with rules $r_0, ..., r_n$, with bodies $b(r) = \{b_0, ..., b_k\}$ and heads $h(r)$, the
overdeletion program will generate one new $-$rule for each $b_j$ in each rule body $b(r_i)$, in order to represent
that if such fact were to be deleted, then $h(r_i)$ would not hold true.

\begin{exmp}{DRED Overdeletion Program}
	\tiny
	\begin{align}
		P = \{ TC(?x, ?z) \leftarrow Edge(?x, ?y), TC(?y, ?z); TC(?x, ?y) \leftarrow Edge(?x, ?y) \} \nonumber                                                \\
		-r_0 = -TC(?x, ?y) \leftarrow -Edge(?x, ?y)                                                                                                           \\
		-r_1 = -TC(?x, ?z) \leftarrow -Edge(?x, ?y), TC(?y, ?z)                                                                                     \nonumber \\
		-r_2 = -TC(?x, ?z) \leftarrow Edge(?x, ?y), -TC(?y, ?z)
	\end{align}
	\label{ex6}
\end{exmp}

On example \ref{ex6} negative predicates represent overdeletion targets. For instance, if \verb|Edge(2, 3)| is
being deleted, then \verb|TC(2, 3)| will be deleted, and any other inferred fact that depends on it. Given that
it is a regular datalog program, it can be efficiently evaluated with semi-naive evaluation.

The next step is to compute the alternative derivations of the deleted facts, since some overdeleted facts might
still hold true. The alternative derivation program will generate one new $+$rule for each $r_i$ in $P$, with
one extra $-$ head predicate per body, representing an overdeleted fact. The $+$ program requires the overdeleted
facts to not be present.

\begin{exmp}{DRED Alternative Rederivation}
	\tiny
	\begin{align}
		P = \{ TC(?x, ?z) \leftarrow Edge(?x, ?y), TC(?y, ?z); TC(?x, ?y) \leftarrow Edge(?x, ?y) \} \nonumber                                                           \\
		r_0 = +TC(?x, ?y) \leftarrow -TC(?x, ?y), Edge(?x, ?y)                                                                                                           \\
		r_1 = +TC(?x, ?z) \leftarrow -TC(?x, ?z), Edge(?x, ?y), TC(?y, ?z)                                                                                     \nonumber \\
	\end{align}
	\label{ex7}
\end{exmp}

The output relations from example \ref{ex7} represent the data that has to be put back into the materialization.
The rationale for alternative derivations is that, for $r_1$, for instance, if the edge \verb|TC(3, 4)| was
overdeleted, because of there being \verb|Edge(1, 2)| and \verb|TC(2, 3)|, if \verb|Edge(3, 4)| was not deleted, by
rule $r_0$, then there is an alternative derivation for \verb|TC(3, 4)|.

As it can be seen, computing the maintenance of the materialization implies evaluating a program bigger than the
materialization itself, however, due to the fact that it is evaluated with semi-naive evaluation, the asymptotic
complexity remains the same\cite{complexity_of_dred}. Nonetheless, in practice, deletion is often much slower than
addition, as it can be trivially seen by the worst-possible scenario, in which all facts are deleted, where while
materialization would be free, DRED would inquire an expensive overdeletion computation.

\subsection{Infer}
The most relevant performance-oriented aspect of both of the introduced evaluation mechanisms is the implementation
of $I_c$ itself. The two most high-profile methods to do so are either purely evaluating the rules, or rewriting
them in some other imperative formalism, and executing it.

The Infer\cite{datalog} method is the simplest example of the former, and relies on substitutions. A substitution $S$ is a homomorphism
$[x_1 \rightarrow y_1, ..., x_i \rightarrow y_i]$, such that $x_i$ is a variable, and $y_i$ is a constant. Given a not-ground fact,
such as $TC(?x, 4)$, \textit{applying} the substitution $[?x \rightarrow 1]$ to it will yield the ground fact $TC(1, 4)$.

Infer relies on attempting to build and extend substitutions for each fact in each rule body over every single $DB$ fact. Once
all substitutions are made, they are applied to the heads of each rule. Every result of this application that is ground belongs
to the immediate consequence.

\subsection{Relational Algebra}
Relational Algebra\cite{codd_1970} explicitly denotes operations over sets of tuples with fixed arity, relations. It is
the most popular database formalism that there is, with virtually every single major database system adhering to the
relational model\cite{pg,mysql,sqlserver} and using SQL as a declarative syntax for relational algebra.

Let $R$ and $T$ be relations with arity $r$ and $t$, $\theta$ be a binary operation with a boolean output, $R(i)$ be
the i-th column, all terms in the i-th position of every tuple in $R$, and $R[h, ..., k]$ be the subset of $R$ such
that only the columns $h, ..., k$ remain, and Const the set of all constant terms. The following are the most relevant
relational algebra operators and their semantics:
\begin{itemize}
	\item Selection by column $\sigma_{i=j)}(R) = \{ a \in R | a(i) == a(j) \}$
	\item Selection by value $\sigma_{i=k}(R) = \{a \in R | a(i) == k \}$
	\item Projection $\pi_{h, ..., k}(R) = \{(R(i), ..., R(j), \overrightarrow{C}) |  i, j >= 1 \wedge i, j <= r\ \wedge \forall c \in C. c \in \text{Const}$
	\item Product $\times(R, T) = \{(a, b) | a \in R \wedge b \in T \}$
	\item Join $\Join_{i=j} = \{(a, b) | a \in R \wedge b \in T \wedge a(i) == b(j)\}$
\end{itemize}

Rewriting datalog into some form of relational algebra has been the most successful strategy employed by the vast majority of all
current state-of-the-art reasoners\cite{bigdatalog, cog, nexus, recstep, dcdatalog, souffle} mostly due to the extensive industrial
and academic research into developing data processing frameworks that process very large amounts of data, and the techniques that
have arisen from these.

In spite of this, there is no open-source library that provides a stand-alone datalog to relational algebra translator, therefore every single
datalog evaluator has to repeat this effort. Moreover, datalog rules translate to a specific form of relational algebra expressions, the
select-project-join $\mathcal{SPJ}$ form.

A relational algebra expression is in the $\mathcal{SPJ}$ form if it consists solely of select, project and join operators. This form
is very often seen in practice, being equivalent to \verb|SELECT ... FROM ... WHERE ...| SQL queries, and highly benefits from being
equivalent to conjunctive queries, that are equivalent to single-rule and non-recursive datalog programs.

\section{Differential Datalog}

\emph{Timely dataflow} is a high-throughput, low-latency
streaming-and-distributed computational model that extends the dataflow paradigm. The timely
in its name refers to it thoroughly establishing the semantics of each aspect of communication
notification, taking the parallelization blueprint and making its execution transparent to the user.

\emph{Differential dataflow}, a generalization of incremental processing, is an extension to the
timely dataflow model. While the shape of the data that flows in the latter is in the form
of \verb|(data, timestamp)|, the former's is \verb|(data, timestamp, multiplicity)|, therefore
restricting its bag-of-data semantics to multisets, with the multiplicity element representing a
difference, for instance, $+1$ representing the addition of $1$ datapoint arriving at a
specific timestamp, or $-1$, a deletion.

The key difference between both models is that similarly to how timely makes distribution
transparent, differential does the same with incremental computation, by providing to the user the
possibility of not only adding to a stream, the only possible action in timely dataflow, but
allow it to respond to arbitrary additions and retractions at any timestamp.  There is one
reasoner that uses differential dataflow\cite{ddlog}, however, it has no storage layer, instead
it compiles fixed datalog programs into fixed differential dataflow programs, that can only run in one computer.

The lack of a canonical open-source implementation of datalog makes attempts at making
empirical statements about performance-impacting theoretical developments, such as the usage of
differential dataflow, brittle and difficult, since there is no point of reference to
compare and validate, and comparisons against commercial implementations are not
reliable, since optimizations might be trade secrets.

A notorious exploration that highlights this issue is the COST, Configuration That Outperforms
a Single Thread, article\cite{COST}, in which the author posits that multiple published
graph-processing engines are likely never able to outperform simple single-threaded implementations.
Some high-profile datalog implementations were built upon systems mentioned on that article.
Later on, the author made multiple pieces of informal writing in which the most performant datalog
engines were investigated for COST\cite{blogdynamicdatalog, blogvldbsigmod}, with results that
showed a very different picture than the ones depicted by the original articles.

The \verb|Differential| engine is an attempt at implementing a substitution-based engine on top of the distribution framework that addresses datalog's
evaluation inefficiencies in a manner that no other currently available framework does, differential dataflow\cite{dd}. Most of the distributed datalog engines are
built on top of either graph-processing or map-reduce frameworks, both kinds of projects that were not specifically made with expressive query answering in mind, but
more with efficiently handling complex non-recursive queries over large amounts of data.

One of the biggest challenges in efficiently evaluating datalog is in the deletion of data. Incremental bottom-up processing of additions is already the
manner in which semi-naive evaluation works, and is relatively efficient. The other direction is significantly more complex. In order to delete a fact,
one has to take into account that it might have influenced the inferrence of other facts, which imply having to look over the whole data, while the opposite
direction does not require that, therefore incurring possibly very large performance differences between both directions.

Similarly to how semi-naive evaluation is the \textit{de facto} method for incremental bottom-up evaluation, the Delete-Rederive\cite{dred} algorithm holds
the same regard with respect to the incremental maintenance of bottom-up evaluation with respect to deletions. There are two stages to it, the first, Deletion,
naively overdeletes all facts that could have been derived from it, but at the same time, keeps track of possible facts that could have had alternative
derivations. The second stage, rederive, restarts the evaluation process.

Differential dataflow directly addresses this issue by evaluating both additions and deletions in the same manner, while at the same time efficiently parallelizing
semi-naive evaluation, however, it is first necessary to digress over Timely Dataflow~\cite{timely}, the underlying networked computation system in which differential
is built upon.

Timely is a high-throughput, low-latency streaming-and-distributed model that extends dataflow. The timely in its name refers to it thoroughly establishing
the semantics of each aspect of communication notification, taking the parallelization blueprint and making its execution transparent to the user. A notification
sent between operators is assigned a timestamp, that needs only to be partially ordered, with no assumptions being made with respect to insertion. The goal is to use
them to correctly reason about the data with respect to the local operator states' of computation completion, in order to cleverly know with certainty when not only
whether should work be done asynchronously or with sharding, but whether there is data yet to be processed or not.

Differential Dataflow, a generalization of incremental processing, is an extension to the Timely Dataflow model. While the shape of the data that flows in the latter is
in the form of \verb|(data, timestamp)|, the former's is \verb|(data, timestamp, multiplicity)|, therefore restricting its bag-of-data semantics to multisets, with
the multiplicity element representing a difference, for instance, $+1$ representing the addition of $1$ datapoint arriving at a specific timestamp, or $-1$, a deletion. The
key difference between both models is that similarly to how timely makes distribution transparent, differential does the same with incremental computation, by providing to the
user the possibility of not only adding to a stream, the only possible action in timely dataflow, but allow it to respond to arbitrary additions and retractions at any timestamp.

Similarly to how timestamps in timely are the key element to the efficient parallelization of iterative dataflows, they can also be used in incremental scenarios in order to
overcome their inherently sequential nature. This is of paramount importance to the performance of datalog evaluation.

Let's assume that there is some dataflow that computes the transitive closure of some graph $d_0$, and one update consisted of four edge differences, labeled as $\delta$, arrives, with
the resulting updated graph being $d_1$. In a regular incremental system, each triple would increment the iteration counter by $1$, and even though the relational operations inside
the dataflow might happen in parallel, $\delta_1$, $\delta_2$, $\delta_3$ and $\delta_4$ will only be evaluated after $\delta_0$ and each of its sequent difference's iteration finishes.

If that dataflow were to be executed with differential dataflow, inside the iteration scope there would be a product timestamp $\langle a, b \rangle$, with $a$ representing the time
in which some initial triple was fed into the computation, and $b$ denoting the iteration count, therefore tracking the transitive chain length, respecting the
following partial order: \[\langle a_i, b_1 \rangle \leq \langle a_j, b_j \rangle \iff a_i \leq a_j \wedge b_i \leq b_j\]

If we take that $\delta_0$, $\delta_3$, $\delta_1$ and $\delta_2$ are differences with the following respective timestamps: $\langle 0, 1 \rangle, \langle 0, 2 \rangle, \langle 1, 1 \rangle, \langle 1, 2 \rangle$ it
is noticiable that $\delta_0$ and $\delta_3$ are comparable, but both of them, and vice-versa, are incomparable with respect to $\delta_1$ and $\delta_2$. This, in turn, means that, as it can
these pairs of differences, despite notifying change on the same iteration operator, could safely be executed in parallel in differential dataflow, but not in a regular
incremental system that uses totally-ordered timestamps.

The most notable difference between iterative and incremental processing is that in the latter computation advances by, ideally, making adjustments proportional to the newly
received data, referred to as difference. Naturally, this could result in massively reduced latency, however, in order to support this in the first place, incremental
systems have to maintain indexes of all updates, be it an addition or a retraction, that could impact the calculation.

The differential dataflow implementation, built on top of timely dataflow's rust one, utilizes a novel method to maintain indexes such that they are not restricted
to each individual operator, and could also be shared between multiple readers. This method utilizes shared arrangements, out of which its core concept, collection
trace, is a structure that represents the state of a collection since the latest frontier, as explained in the timely dataflow section, as an append-only ordered sequence
of batches of updates, with each batch possibly being merged with other batches, that make up an LSM-Tree~\cite{lsm}, therefore benefitting from its compaction mechanism
to ensure that only a logarithmic number of batches exist.

\section{Experiments}

The aim of the experiments is to showcase relative performance, and scalability. Given that all reasoners to be compared share as much code as possible, are written in the same
programming language, and use the same elementary memory model, possibly strong empirical statements can be made with respect to the specificities of their implementation.

\textbf{Setup.} The experiments were run on commodity hardware, a MacbookPro with an M1 Pro processor and 16GB of ram, and in no test did swap memory was reached for.
Rust version 1.65 was used.

\begin{table}[]
	\begin{tabular}{llll}
		Dataset    & Area             & Programs   \\
		linux      & program analysis & CSPA, CSDA \\
		postgresql & program analysis & CSPA, CSDA \\
		httpd      & program analysis & CSPA, CSDA \\
		LUBM       & semantic web     & RhoDFS
	\end{tabular}
	\label{table:datasets}
\end{table}

\textbf{Datasets.} On table \ref{table:datasets} all datasets and program names, or acronyms, are shown. There are two areas of interest. The first is program analysis, a highly active research
field that has propelled significant advancements in datalog reasoners, such as \cite{incA}, an incremental datalog engine extended with lattices and recursive aggregates, and
souffle\cite{souffle}, a priceless source of more than half a dozen papers on the engineering aspects of a reasoner. While the latter's point is to run pre-defined programs over
large datasets, the former is meant for more dynamic scenarios, such as in running and maintaining program analyses.

The semantic web has very unique use-cases for datalog, and are the leading source of research in extending datalog. Seeking ways to introduce tuple-generating dependencies to
programs, with evaluation remaining tractable, has been one of the most active research directions, with highly-influential papers establishing new families of datalog
languages\cite{datalog_plus_minus} and thoroughly exploring their complexity classes alongside further expansions\cite{sticky,warded,monadic}.

These advancements have been somewhat tested in practice, albeit with no full reference implementation having been specified. The most comprehensive, and recent, is closed-source\cite{vadalog}.
The leading datalog engine in general, is also closed-source\cite{rdfox}, and is tailored specifically to the semantic web.

\begin{exmp}{Context-sensitive Points-to Analysis Program}
	\tiny
	\begin{align}
		valueFlow(?x, ?y) \leftarrow assign(?x, ?y)                                                 \\
		valueFlow(?x, ?z) \leftarrow assign(?x, ?y), memoryAlias(?y, ?z)                            \\
		valueFlow(?x, ?z) \leftarrow valueFlow(?x, ?y), valueFlow(?y, ?z)                           \\
		memoryAlias(?x, ?w) \leftarrow dereference(?x, ?y), valueAlias(?y, ?z), dereference(?z, ?w) \\
		valueAlias(?y, ?z) \leftarrow valueFlow(?x, ?y), valueFlow(?x, ?z)                          \\
		valueAlias(?y, ?z) \leftarrow valueFlow(?x, ?y), memoryAlias(?x, ?w), valueFlow(?w, ?z)     \\
		valueFlow(?x, ?x) \leftarrow assign(?x, ?y)                                                 \\
		valueFlow(?x, ?x) \leftarrow assign(?y, ?x)                                                 \\
		memoryAlias(?x, ?x) \leftarrow assign(?y, ?x)                                               \\
		memoryAlias(?x, ?x) \leftarrow assign(?x, ?y)
	\end{align}
	\label{program:cspa}
\end{exmp}

\begin{exmp}{Context-sensitive Dataflow Analysis}
	\tiny
	\begin{align}
		null(?x, ?y) \leftarrow nullEdge(?x, ?y) \\
		null(?x, ?y) \leftarrow null(?x, ?y), arc(?y, ?z)
	\end{align}
	\label{program:csda}
\end{exmp}

\begin{exmp}{RhoDFS inference rules}
	\tiny
	\begin{align}
		A(?y, rdf:type, ?x) \leftarrow T(?a, rdfs:domain, ?x), A(?y, ?a, ?z)                                  \\
		A(?z, rdf:type, ?x) \leftarrow T(?a, rdfs:range, ?x), A(?y, ?a, ?z)                                   \\
		T(?x, rdfs:subPropertyOf, ?z) \leftarrow T(?x, rdfs:subPropertyOf, ?y), T(?y, rdfs:subPropertyOf, ?z) \\
		T(?x, rdfs:subClassOf, ?z) \leftarrow T(?x, rdfs:subClassOf, ?y), T(?y, rdfs:subClassOf, ?z)          \\
		A(?z, rdf:type, ?y) \leftarrow T(?x, rdfs:subClassOf, ?y), A(?z, rdf:type, ?x)                        \\
		A(?x, ?b, ?y) \leftarrow T(?a, rdfs:subPropertyOf, ?b), A(?x, ?a, ?y)
	\end{align}
	\label{program:rhodfs}
\end{exmp}

The first program, \ref{program:cspa}\cite{graspan}, expresses pointer analysis, whose goal is to establish which assignments yield value aliases and memory aliases as a reachability problem. Program \ref{program:csda} directly models checking a program's control-flow graph for null edges as a simple transitive-closure computation. The last program, \ref{program:rhodfs}, is used to materialize the non-trivial inference rules from RDFS\cite{rdfs}, a popular data modelling logic for adding semantics to RDF\cite{rdf} data.

\subsection{COST}

\begin{figure}[ht]
	\centering
	\includegraphics[width=.45\textwidth,height=\textheight,keepaspectratio]{COST}
	\caption{The COST of differential reasoner}
	\label{benchmark:cost}
\end{figure}

Benchmark \cite{benchmark:cost} seeks to answer an important question that is often overlooked, what is the configuration that outperforms a single thread(COST)? this can be convincingly answered in shapiro. As it can be seen, on the LUBM dataset, a synthetic infinitely-scalable ontology, in order to fully materialize all data at once, differential reasoner performs on par with the substitution-based reasoner, showcasing the very little overhead that differential dataflow has, given that it implements the same algorithm as the substitution-based reasoner.

\subsection{Scalability.}

\begin{figure}[ht]
	\centering
	\subfloat[]{\includegraphics[width=.5\textwidth,height=\textheight,keepaspectratio]{addition}\label{benchmark:scalability_addition}}%
	\subfloat[]{\includegraphics[width=.5\textwidth,height=\textheight,keepaspectratio]{deletion}\label{benchmark:scalability_deletion}}\\
	\caption{Scalability with respect to update size}
	\label{benchmark:scalability}
\end{figure}

Scalability is measured over the LUBM dataset over increasingly larger relative updates. There are two kinds of updates: additions and deletions, both as a percentage of the total data. It is evident from benchmark \cite{benchmark:scalability} that all reasoners scale linearly with respect to the increasing amount of data, however, there is a significant difference with respect to updates. Both non-differential reasoners seem to get polynomially slower with bigger deletion update sizes than differential dataflow.

\subsection{Multiple Datasets.}

\begin{figure}[ht]
	\centering
	\subfloat[]{\includegraphics[width=.5\textwidth,height=\textheight,keepaspectratio]{CSDA}\label{benchmark:CSDA}}%
	\subfloat[]{\includegraphics[width=.5\textwidth,height=\textheight,keepaspectratio]{CSPA}\label{benchmark:CSPA}}\\
	\caption{Multiple programs with different datasets}
	\label{benchmark:scalability}
\end{figure}

The last benchmark, pertaining to program analysis, is used to explore the possibly performance differences for completely different datasets, with the same programs. Benchmark \cite{benchmark:csda} is the most surprising, since differential dataflow significantly outperforms the other implementations, while this isn't the case in any other benchmark. The rationale behind that, is that in both non-differential reasoners, iteration implies cloning a non-trivial amount of data, therefore generating a large amount of allocations, while the differential version also makes a large number of allocations, it parallelizes iterations, due to its partially-ordered timestamp, being able to concurrently progress multiple independent transitive chains at once.

\section{Conclusion}

In this paper we introduced Shapiro, a reasoning framework whose core value proposition is in providing modular components to build datalog reasoners. We utilized it to build a reasoner with a promising differential computation framework, differential dataflow, and evaluated it against two other reference implementations. The differential implementation bested its non-differential counterpart, showing very little overhead, however, it did not get close to a relational implementation, the current state-of-the-art approach, nor could it scale as well as the others, nonetheless, it did manage to handle updates in a much more efficient manner, performing exactly as well in additions as in deletions, therefore being much more efficient in practical situations, where no assumption about the kind of update can be made, than both implementations. This yields promising evidence as to the suitability of differential dataflow's computational model to datalog evaluation.
%
%
% \textbf{Contributions.} In this article we make several contributions to clarifying, benchmarking
% and easing pushing the boundaries of datalog evaluation engineering research further by
% providing performant and open-source implementations of single-threaded, parallel and distributed evaluators.
%
% \begin{itemize}
%   \item \textbf{Techniques and Guidelines.} We study the challenge of building a reasoner from scratch,
%         with no underlying framework, and ponder over all decisions necessary in order to bring that to fruition,
%         alongside with relevant recent literature.
%   \item \textbf{Differential Dataflow.} We accurately investigate the suitability of differential
%         dataflow for datalog, and showcase how does it fare against the ubiquitous DRED and semi-naive
%         evaluation based reasoners with the same language, base and with the same data format.
%   \item \textbf{Framework.} All code outputs of this article are coalesced in a rust library named shapiro,
%         consisted of a datalog to relational algebra rewriter, a relational algebra evaluator, and two datalog engines,
%         one that is parallel-capable and supports both substitution-based and relational algebra methods, and other that
%         relies on the state-of-the-art differential dataflow\cite{differential_dataflow} distribution computation framework.
%         The main expected outcome of this library is to provide well understood and reasoned about baseline implementations
%         from where future research can take advantage of, and reliable COST configurations can be attained.
%   \item \textbf{Benchmarking.} We perform two thorough benchmark suites. One evaluates the performance of the developed
%         relational reasoner with multiple different index data structures and common optimizations, such as string interning
%         and simple parallelism, and another that attempts to attain the COST of the reasoner built on top of differential
%         dataflow. The selected datasets are either from the program analysis, heavy users of not-distributed datalog, or from
%         the semantic web community, which has multiple popular infinitely-scalable benchmarks.
% \end{itemize}

\bibliographystyle{ACM-Reference-Format}
\bibliography{software}

\end{document}
\endinput
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
